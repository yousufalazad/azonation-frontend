// helpers/excelExport.js
import ExcelJS from "exceljs";
import dayjs from "dayjs";
import { authStore } from "../store/authStore";

const auth = authStore;

/* ----------------------- Main Export ----------------------- */
export async function excelExport({ headers = [], rows = [], title = "Report", fileName = "export.xlsx" } = {}) {
  try {
    // Normalize headers
    let normalizedHeaders;
    if (!Array.isArray(headers)) {
      normalizedHeaders = Object.keys(headers || {}).map((k) => ({ text: k, value: k }));
    } else if (headers.length === 0) {
      normalizedHeaders = [];
    } else if (typeof headers[0] === "string") {
      normalizedHeaders = headers.map((h) => ({ text: h, value: h }));
    } else {
      normalizedHeaders = headers.map((h) => ({
        text: h.text ?? h.label ?? h.title ?? String(h.value ?? h.key ?? ""),
        value: h.value ?? h.key ?? (typeof h.text === "string" ? h.text : String(h.text ?? "")),
      }));
    }

    const totalCols = Math.max(1, normalizedHeaders.length);
    const orgName = auth?.user?.org_name ?? "Azonation";
    const today = dayjs().format("YYYY-MM-DD");

    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet("Sheet1");

    /* ---------------- Header ---------------- */
    let curRow = 1;

    // Org name
    ws.mergeCells(curRow, 1, curRow, totalCols);
    ws.getCell(curRow, 1).value = orgName;
    ws.getCell(curRow, 1).font = { size: 16, bold: true };
    ws.getCell(curRow, 1).alignment = { horizontal: "center", vertical: "middle" };
    curRow++;

    // Report title
    ws.mergeCells(curRow, 1, curRow, totalCols);
    ws.getCell(curRow, 1).value = title;
    ws.getCell(curRow, 1).font = { size: 12, bold: true, color: { argb: "FF000000" } }; // black title
    ws.getCell(curRow, 1).alignment = { horizontal: "center", vertical: "middle" };
    curRow++;

    ws.addRow([]);
    curRow++;

    /* ---------------- Table ---------------- */
    const headerLabels = normalizedHeaders.map((h) => h.text);
    const headerRow = ws.addRow(headerLabels);
    headerRow.eachCell((cell) => {
      cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFD9D9D9" } }; // light gray headers
      cell.font = { bold: true, color: { argb: "FF000000" } }; // black text
      cell.alignment = { horizontal: "center", vertical: "middle" };
      cell.border = {
        top: { style: "thin", color: { argb: "FFCCCCCC" } },
        left: { style: "thin", color: { argb: "FFCCCCCC" } },
        bottom: { style: "thin", color: { argb: "FFCCCCCC" } },
        right: { style: "thin", color: { argb: "FFCCCCCC" } },
      };
    });

    (rows || []).forEach((r) => {
      const rowVals = normalizedHeaders.map((hdr) => {
        if (typeof hdr.value === "function") {
          try { return hdr.value(r); } catch { return ""; }
        }
        return r?.[hdr.value] ?? r?.[hdr.text] ?? "";
      });
      const newRow = ws.addRow(rowVals);
      newRow.eachCell((cell) => {
        cell.alignment = { horizontal: "left", vertical: "middle" };
        cell.border = {
          top: { style: "thin", color: { argb: "FFEEEEEE" } },
          left: { style: "thin", color: { argb: "FFEEEEEE" } },
          bottom: { style: "thin", color: { argb: "FFEEEEEE" } },
          right: { style: "thin", color: { argb: "FFEEEEEE" } },
        };
      });
    });

    ws.addRow([]);

    /* ---------------- Footer ---------------- */
    const footerRowIndex = ws.lastRow.number + 1;
    const part1End = Math.floor(totalCols / 3);
    const part2Start = part1End + 1;
    const part2End = Math.floor((2 * totalCols) / 3);
    const part3Start = part2End + 1;

    ws.mergeCells(footerRowIndex, 1, footerRowIndex, Math.max(1, part1End));
    ws.getCell(footerRowIndex, 1).value = `Generated by ${orgName} on ${today}`;
    ws.getCell(footerRowIndex, 1).alignment = { horizontal: "left", vertical: "middle" };

    ws.mergeCells(footerRowIndex, part2Start, footerRowIndex, Math.max(part2Start, part2End));
    ws.getCell(footerRowIndex, part2Start).value = `Items 1â€“${rows?.length ?? 0} of ${rows?.length ?? 0}`;
    ws.getCell(footerRowIndex, part2Start).alignment = { horizontal: "center", vertical: "middle" };

    ws.mergeCells(footerRowIndex, part3Start, footerRowIndex, totalCols);
    ws.getCell(footerRowIndex, part3Start).value = `Page 1 of 1`;
    ws.getCell(footerRowIndex, part3Start).alignment = { horizontal: "right", vertical: "middle" };

    ws.getRow(footerRowIndex).eachCell((cell) => {
      cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFE5E7EB" } }; // light gray footer
      cell.font = { italic: true, color: { argb: "FF374151" } }; // dark gray text
    });

    /* ---------------- Auto width ---------------- */
    ws.columns.forEach((col) => {
      let maxLength = 10;
      col.eachCell({ includeEmpty: true }, (cell) => {
        const v = cell.value ?? "";
        maxLength = Math.max(maxLength, String(v).length);
      });
      col.width = Math.min(Math.max(maxLength + 2, 10), 60);
    });

    /* ---------------- Save ---------------- */
    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const safeName = /\.xlsx$/i.test(fileName) ? fileName : `${fileName}.xlsx`;
    a.download = safeName;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);

  } catch (err) {
    console.error("excelExport error:", err);
    throw err;
  }
}
